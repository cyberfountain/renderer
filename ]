import type { ElementWithCache } from "./element";
import type { Hole } from "./holes/Hole";
import { TemplateHole } from "./holes/TemplateHole";
import type { Attributes } from "./constants";
import { TEMPLATE_MARKER_GLYPH } from "./constants";
import { getIndexFromComment, makeMarkerComment } from "./utils";

type AttributeDefinition = {
  index: number;
  comment: string;
  type: Attributes;
};

export class TemplateFragment {
  private htmlString = "";
  private holes = new Map<number, Hole>();
  private attributeMap = [];

  constructor(strings: TemplateStringsArray) {
    this.parse(strings);
  }

  private parse(strings: TemplateStringsArray): void {
    const len = strings.length;
    for (let i = 0; i < len; i++) {
      this.htmlString += strings[i];
      if (i < strings.length - 1) {
        const regex = /(\S+)(?==(?:["']?)$)/;
        const match = this.htmlString.match(regex);

        if (match) {
          console.log(match[1]);
        }

        this.htmlString += makeMarkerComment(i);
      }
    }
  }

  private initFragment(): DocumentFragment {
    const template = document.createElement("template");
    template.innerHTML = this.htmlString;
    return template.content;
  }

  private hydrateAttributes(fragment: DocumentFragment): DocumentFragment {
    // return attributes map key and value
    // console.log(f.querySelector("[\\@click]")); Deal with attributes here
    return fragment;
  }

  private hydrateTemplateHoles(fragment: DocumentFragment): DocumentFragment {
    const walker = document.createTreeWalker(
      fragment,
      NodeFilter.SHOW_COMMENT,
      // eslint-disable-next-line no-null/no-null
      null,
    );

    while (walker.nextNode()) {
      const node = walker.currentNode;

      if (node.nodeValue?.includes(TEMPLATE_MARKER_GLYPH)) {
        const holeIndex = getIndexFromComment(node.nodeValue);
        const expressionMarker = new TemplateHole();
        node.parentNode?.insertBefore(expressionMarker.node, node);
        this.holes.set(holeIndex, expressionMarker);
      }
    }

    return fragment;
  }

  public mount(container: ElementWithCache): void {
    const fragment = this.initFragment();
    this.hydrateTemplateHoles(fragment);
    this.hydrateAttributes(fragment);
    container.appendChild(fragment);
  }

  public update(values: unknown[]): void {
    for (const [index, hole] of this.holes) {
      hole.setValue(values[index]);
    }
  }
}
